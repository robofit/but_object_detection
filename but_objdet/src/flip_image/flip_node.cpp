/******************************************************************************
 * \file
 *
 * $Id:$
 *
 * Copyright (C) Brno University of Technology
 *
 * This file is part of software developed by dcgm-robotics@FIT group.
 *
 * Author: Michal Kapinus
 * Supervised by: Vitezslav Beran (beranv@fit.vutbr.cz), Michal Spanel (spanel@fit.vutbr.cz)
 * Date: 01/04/2012
 *
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this file.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <ros/ros.h> // Main header of ROS

// ObjDet API
#include "but_objdet/but_objdet.h" // Main objects of ObjDet API
#include "but_objdet/services_list.h" // Names of services provided by but_objdet package
#include "but_objdet/PredictDetections.h" // Autogenerated service class
#include "but_objdet/GetObjects.h" // Autogenerated service class
#include "but_objdet_msgs/DetectionArray.h" // Message transfering detections/predictions

#include <opencv2/highgui/highgui.hpp>
#include <cv_bridge/cv_bridge.h>

#include "but_objdet/flip_image/flip_node.h"



using namespace std;
using namespace cv;
using namespace but_objdet_msgs;

// If set to 1, detections will be visualized. If a tracker node is used, it is
// better to visualize the detections together with predictions there.
#define VISUAL_OUTPUT 0

const string imageTopicIn = "/camera/rgb/image_color";
const string depthTopicIn = "/camera/depth/image";
const string imageTopicOut = "/cam3d/rgb/image";
const string depthTopicOut = "/cam3d/depth/image";
const string detectionTopic = "/but_objdet/detections";


namespace but_objdet
{

/* -----------------------------------------------------------------------------
 * Constructor
 */
FlipImageNode::FlipImageNode()
{   
    

    rosInit(); // ROS-related initialization
}


/* -----------------------------------------------------------------------------
 * Destructor
 */
FlipImageNode::~FlipImageNode()
{
    
	
    
    // Create a window to vizualize the incoming video, detections and predictions
    if(VISUAL_OUTPUT) {
        namedWindow(winName, CV_WINDOW_AUTOSIZE);
    }
}


/* -----------------------------------------------------------------------------
 * ROS-related initialization
 */
void FlipImageNode::rosInit()
{
    
   
        // Subscribe to a topic with images
    imgSub = nh.subscribe(imageTopicIn, 10, &FlipImageNode::newImageCallback, this);
   
    imgPub = nh.advertise<sensor_msgs::Image>(imageTopicOut, 1);
    
    depthSub = nh.subscribe(depthTopicIn, 10, &FlipImageNode::newDepthCallback, this);
   
    depthPub = nh.advertise<sensor_msgs::Image>(depthTopicOut, 1);
    
    
    // Inform that the tracker is running (it will be written into console)
    ROS_INFO("Flipper is runnging...");
}



/* -----------------------------------------------------------------------------
 * Callback function called when new Image is received. The image is used just
 * for visualization of detections and predictions, thus it doesn't influence
 * functionality of this node in any way.
 */
void FlipImageNode::newImageCallback(const sensor_msgs::ImageConstPtr &imageMsg)
{

    // Get an OpenCV Mat from the image message
    
    cv_bridge::CvImagePtr cv_ptr(new cv_bridge::CvImage);
    try {
        
        cv_ptr = cv_bridge::toCvCopy(imageMsg, imageMsg->encoding);
	
    }    catch (cv_bridge::Exception& e) {
        ROS_ERROR("cv_bridge exception: %s", e.what());
        return;
    }
    
    cv::flip(cv_ptr->image,cv_ptr->image,0);
      
    
   
    
    imgPub.publish(cv_ptr->toImageMsg());
    
    if(VISUAL_OUTPUT) {
        imshow(winName, cv_ptr->image);
    }
}


/* -----------------------------------------------------------------------------
 * Callback function called when new Image is received. The image is used just
 * for visualization of detections and predictions, thus it doesn't influence
 * functionality of this node in any way.
 */
void FlipImageNode::newDepthCallback(const sensor_msgs::ImageConstPtr &imageMsg)
{

    // Get an OpenCV Mat from the image message
    
    cv_bridge::CvImagePtr cv_ptr(new cv_bridge::CvImage);
    try {
        
        cv_ptr = cv_bridge::toCvCopy(imageMsg, imageMsg->encoding);
	
    }    catch (cv_bridge::Exception& e) {
        ROS_ERROR("cv_bridge exception: %s", e.what());
        return;
    }
    
    cv::flip(cv_ptr->image,cv_ptr->image,0);
      
    
   
    
    depthPub.publish(cv_ptr->toImageMsg());
    
    if(VISUAL_OUTPUT) {
        imshow(winName, cv_ptr->image);
    }
}
}



/* =============================================================================
 * Main function
 */
int main(int argc, char **argv)
{
    // ROS initialization (the last argument is the name of a ROS node)
    ros::init(argc, argv, "but_flip_image");

    // Create the object managing connection with ROS system
    but_objdet::FlipImageNode *node = new but_objdet::FlipImageNode();
    
    // Enters a loop, calling message callbacks
    while(ros::ok()) {
        waitKey(10); // Process window events
        ros::spinOnce(); // Call all the message callbacks waiting to be called
    }
    
    delete node;
    
    return 0;
}

